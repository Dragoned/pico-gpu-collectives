{
  "k_bruck_over": {
    "desc": "libpico external K-nomial Bruck algorithm. It requires an additional parameter `radix`. This algorithm is used for medium to large messages",
    "version": "1.0.0",
    "constraints": [
      {
        "key": "count",
        "conditions": [
          {
            "operator": ">=",
            "value": "comm_sz"
          }
        ]
      }
    ],
    "selection": "pico",
    "additional_parameters": {
      "radix": {
        "desc": "Radix of the K-nomial tree",
        "required": true,
        "type": "int"
      }
    },
    "tags": [
      "k_bruck",
      "cuda",
      "additional_parameter",
      "external"
    ]
  },
  "recursive_doubling_nontowpower_over": {
    "desc": "libpico external recursive doubling algorithm. Works with non power of 2 processes.",
    "version": "1.0.0",
    "selection": "pico",
    "constraints": [
      {
        "key": "count",
        "conditions": [
          {
            "operator": ">=",
            "value": "comm_sz"
          }
        ]
      }
    ],
    "tags": [
      "recursive_doubling",
      "cuda",
      "external"
    ]
  },
  "recursivedoubling_hierarchy_v1_over": {
    "desc": "libpico external recursive doubling algorithm. Use hierarchi condivision schemas",
    "version": "1.0.0",
    "selection": "pico",
    "constraints": [
      {
        "key": "count",
        "conditions": [
          {
            "operator": ">=",
            "value": "comm_sz"
          }
        ]
      }
    ],
    "tags": [
      "recursive_doubling",
      "cuda",
      "external"
    ]
  },
  "recursivedoubling_hierarchy_v2_over": {
    "desc": "libpico external recursive doubling algorithm. Use hierarchi condivision schemas",
    "version": "1.0.0",
    "selection": "pico",
    "constraints": [
      {
        "key": "count",
        "conditions": [
          {
            "operator": ">=",
            "value": "comm_sz"
          }
        ]
      }
    ],
    "tags": [
      "recursive_doubling",
      "cuda",
      "external"
    ]
  },
  "recursivedoubling_hierarchy_v3_over": {
    "desc": "libpico external recursive doubling algorithm. Use hierarchi condivision schemas",
    "version": "1.0.0",
    "selection": "pico",
    "constraints": [
      {
        "key": "count",
        "conditions": [
          {
            "operator": ">=",
            "value": "comm_sz"
          }
        ]
      }
    ],
    "tags": [
      "recursive_doubling",
      "cuda",
      "external"
    ]
  },
  "recursive_doubling_over": {
    "desc": "libpico external recursive doubling algorithm. Works only on power of 2 processes. Comm_sz must be greater or equal to count.",
    "version": "1.0.0",
    "selection": "pico",
    "constraints": [
      {
        "key": "count",
        "conditions": [
          {
            "operator": ">=",
            "value": "comm_sz"
          }
        ]
      },
      {
        "key": "comm_sz",
        "conditions": [
          {
            "operator": "is_power_of_two",
            "value": true
          }
        ]
      }
    ],
    "tags": [
      "recursive_doubling",
      "cuda",
      "external"
    ]
  },
  "ring_over": {
    "desc": "libpico external ring algorithm. This algorithm is used for large messages. Comm_sz must be greater or equal to count.",
    "version": "1.0.0",
    "selection": "pico",
    "constraints": [
      {
        "key": "count",
        "conditions": [
          {
            "operator": ">=",
            "value": "comm_sz"
          }
        ]
      }
    ],
    "tags": [
      "ring",
      "cuda",
      "external"
    ]
  },
  "sparbit_over": {
    "desc": "libpico external sparse bit algorithm. Comm_sz must be greater or equal to count.",
    "version": "1.0.0",
    "selection": "pico",
    "constraints": [
      {
        "key": "count",
        "conditions": [
          {
            "operator": ">=",
            "value": "comm_sz"
          }
        ]
      }
    ],
    "tags": [
      "sparbit",
      "external"
    ]
  },
  "bine_block_by_block_over": {
    "desc": "libpico external bine block by block algorithm. Works only for power of 2 processes",
    "version": "1.0.0",
    "selection": "pico",
    "constraints": [
      {
        "key": "count",
        "conditions": [
          {
            "operator": ">=",
            "value": "comm_sz"
          }
        ]
      },
      {
        "key": "comm_sz",
        "conditions": [
          {
            "operator": "is_power_of_two",
            "value": true
          }
        ]
      }
    ],
    "tags": [
      "bine_block_by_block",
      "block_by_block",
      "bine",
      "external"
    ]
  },
  "bine_block_by_block_over_any_even": {
    "desc": "libpico external bine block by block algorithm. Works for any number of even processes",
    "version": "1.0.0",
    "selection": "pico",
    "constraints": [
      {
        "key": "count",
        "conditions": [
          {
            "operator": ">=",
            "value": "comm_sz"
          }
        ]
      },
      {
        "key": "comm_sz",
        "conditions": [
          {
            "operator": "is_even",
            "value": true
          }
        ]
      }
    ],
    "tags": [
      "bine_block_by_block",
      "block_by_block",
      "bine",
      "external"
    ]
  },
  "bine_send_remap_over": {
    "desc": "libpico external bine remap algorithm. Works only for power of 2 processes. Count must be greater or equal to comm_sz. This version remaps rank to allow the sending of contiguous buffers.",
    "version": "1.0.0",
    "selection": "pico",
    "constraints": [
      {
        "key": "comm_sz",
        "conditions": [
          {
            "operator": "is_power_of_two",
            "value": true
          }
        ]
      },
      {
        "key": "count",
        "conditions": [
          {
            "operator": ">=",
            "value": "comm_sz"
          }
        ]
      }
    ],
    "tags": [
      "bine_remap",
      "bine",
      "external"
    ]
  },
  "bine_2_blocks_over": {
    "desc": "libpico external bine algorithm. Works only for power of 2 processes. Count must be greater or equal to comm_sz. It utilizes a recoursive distance doubling communication pattern (the other bine allgather instead use a recursive distance halving) and handles sparse data with one possible additional communication.",
    "version": "1.0.0",
    "selection": "pico",
    "constraints": [
      {
        "key": "comm_sz",
        "conditions": [
          {
            "operator": "is_power_of_two",
            "value": true
          }
        ]
      },
      {
        "key": "count",
        "conditions": [
          {
            "operator": ">=",
            "value": "comm_sz"
          }
        ]
      }
    ],
    "tags": [
      "bine",
      "cuda",
      "external"
    ]
  },
  "bine_2_blocks_dtype_over": {
    "desc": "libpico external bine algorithm. Works only for power of 2 processes. Count must be greater or equal to comm_sz. It utilizes a recoursive distance doubling communication pattern (the other bine allgather instead use a recursive distance halving) and handles sparse data with derived datatypes.",
    "version": "1.0.0",
    "selection": "pico",
    "constraints": [
      {
        "key": "comm_sz",
        "conditions": [
          {
            "operator": "is_power_of_two",
            "value": true
          }
        ]
      },
      {
        "key": "count",
        "conditions": [
          {
            "operator": ">=",
            "value": "comm_sz"
          }
        ]
      }
    ],
    "tags": [
      "bine",
      "dtype",
      "cuda",
      "external"
    ]
  }
}
